# Java基础

##### （纯手打，可能有错误）

### 1.面向对象和面向过程的区别

​	**面向过程**：面向过程比面向对象性能高，但是不容易维护、不容易复用扩展。

​	**面向对象**：易维护、易复用、易扩展，性能比面向过程低，有封装继承多态的特性。

### 2. Java语言的特点

​	面向对象：封装继承多态，虚拟机实现平台无关性，可靠安全、支持多线程，支持网络编程、编译与解释共存

### 3. JVM、JDK、JRE

​	JVM： Java虚拟机，跨平台使用

![1592230502813](D:\mygit\Study-for-Offer\CS\images\1592230502813.png)

​			.class解释执行比较慢，对于热点代码**（二八原则）**，后面引入JIT编译器，属于运行时编译，第一次编译后，字节码对应的机器码保存下来，可以直接使用。

​		Java虚拟机是运行Java字节码的虚拟机，.class字节码和JVM是一次编译到处运行的关键。

JDK： Java development kit，能创建和编译程序

JRE： Java运行时环境，运行以编译的Java程序，包括JVM、Java类库、Java命令和一些基础构件，不能创建新程序。

### 4. Oracle JDK 和Open JDK 

​	代码几乎完全相同，少部分没有开源



### 5. Java和C++的区别

1. 都是面向对象，支持封装继承多态

2. java不提供指针，程序内存更安全

3. java类是单继承，c++支持多重继承，java接口可以多继承

4. java有自动内存管理，不需要手动释放无用内存

5. C中，字符数组最后有一个‘\0’， java没有，[详细说明](https://blog.csdn.net/sszgg2006/article/details/49148189) ，因为java中一切都是对象，比如数组中有一个length属性，直接确定长度，java和c通信的时候，收到c的字符串1.用trim（）方法，2. 自己实现方法去掉

   

### 6. 什么是java的主类，应用程序和小程序的主类有什么不同?

​	只有一个类是主类，应用程序包含main方法，小程序中主类继承自系统类JApplet或Applet的子类，应用程序主类不要求public，小程序要求public

### 7. java应用程序和小程序差别：

​	应用程序从主线程启动（main），小程序中init (), run(),

### 8. 字符型常量和字符串常量的区别？

1. 形式上：字符常量是单引号，字符串是双引号
2. 含义上：字符常量相当于一个ASCII值，可以参与表达式运算，字符串常量代表内存中的一个地址
3. 字符常量占2字节，字符串常量不一定  **（char 在java中  两个字节）**

### 9. 构造器Constructor 是否能被 override 重写

​	 构造器不能被重写，**重写要求方法名不变，而构造方法必须与类名一致但是子类和父类的类名不同**，但是可以overload 重载，所以一个类中可以有多个构造函数，



### 10. 重载和重写

​	 **重载**（Overload）是让类以统一的方式处理不同类型数据的一种手段， 发生在同一类中，方法名相同参数类型、个数、顺序、返回值、访问修饰符可以不同，

​	 **重写**（Override）是父类与子类之间的多态性，实质是对父类的函数进行重新定义，方法名参数列表相同，返回值范围小于父类，访问修饰符大于等于父类，private方法不能被重写，需要父类可以用**super**关键字，**只改变行为，不变外貌**

### 11.  封装 继承 多态

​	封装：把客观事物封装成抽象的类，把一个对象的属性私有化，不同级别的保护数据或代码，不能被外界访问

|        | Public | Protected | Default | Private |
| ------ | ------ | --------- | ------- | ------- |
| 同类   | √      | √         | √       | √       |
| 同包   | √      | √         | √       |         |
| 子类   | √      | √         |         |         |
| 通用性 | √      |           |         |         |

​	继承： 让某个类型的对象获得另一个类型的对象的属性的方法 

​					1.子类有父类对象的所有属性和方法包括私有属性和方法，但是不能访问**只是拥有**

​					2.子类可以有自己的属性和方法

​					3.子类可以用自己的方式实现父类的方法

​	多态： 程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时不确定，而是				在程序运行期间才确定  ，**即一个引用变量到底会指向哪个类的实例对象、发出的方法调用到底是哪个				类实现的方法，必须在程序运行时才能决定**

​				java中有两种形式可以实现多态：继承（多个子类重写同一方法） 接口（实现接口并覆盖同一方法）



### 12. String、StringBuffer和StringBuilder的区别是什么，String为什么不是可变的？

可变性：**String类**：使用final修饰字符数组保存字符串，**private final char value[]**，所以String对象不可变

​				Java 9之后，变为byte数组存储**private final byte value[]**

​				StringBuffer和StringBuilder继承AbstractStringBuilder类，也用字符数组保存，但是没有final，所以可				变。

线程安全性：string安全，StringBuilder安全（加了同步锁），StringBuilder线程不安全。

性能：String每次改变都生成新的对象，StringBuilder比StringBuilder性能差一点但是更安全



###  13. 自动装箱和拆箱

装箱：将基本类型用它们对应的引用类型包装起来， 装箱过程是通过调用包装器的valueOf方法实现的 

拆箱：将包装类型转换为基本数据类型， 拆箱过程是通过调用包装器的 xxxValue 方法实现的

 Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的， valueOf 方法中-128-127范围内，是返回已存在的对象：

```java
public class  Main {
   public static void main(String[] args) {
    
     Integer i1 = 100;
     Integer i2 = 100;
     Integer i3 = 200;
     Integer i4 = 200;
     
     System.out.println(i1==i2);  //true
     System.out.println(i3==i4);  //false
   }
}
```



double、float  的valueOf方法的实现是类似的。  在某个范围内的整型数值的个数是有限的，而浮点数却不是 

```java
public class Main {
   public static void main(String[] args) {
 	 Double i1 = 100.0;
	 Double i2 = 100.0;
	 Double i3 = 100.0;
	 Double i4 = 100.0;
 
 	System.out.println(i1==i2);  //false
	 System.out.println(i3==i4);  //false
    }
}
```


boolean

```java
public class Main {
   public static void main(String[] args) {
    
     Boolean i1 =  false;
     Boolean i2 =  false;
     Boolean i3 =  true;
     Boolean i4 =  true;
    
     System.out.println(i1==i2);  // true
     System.out.println(i3==i4);  // true
   }
}
```

[深入剖析Java中的装箱和拆箱]( https://www.cnblogs.com/dolphin0520/p/3780005.html )





### 14. 静态方法中调用一个非静态成员为什么非法？

静态方法不能通过对象进行调用，在静态方法里，不能调用其他非静态变量，也不能访问非静态变量成员



### 15. 在Java中定义一个不做事且没有参数的构造方法的作用

Java程序在执行子类的构造方法之前，如果没有用super()调用父类特定的构造方法，则调用父类的无参构造，如果子类没有用super且父类没有构造方法，则编译出错



### 16. import java 和 javax 有什么区别？

刚开始必需的包是java开头的，javax只是作为扩展API，之后javax包是标准API的一部分，，实际上没有区别。



### 17. 接口和抽象类的区别？

|            | 抽象类                                               | 接口                                                         |
| ---------- | ---------------------------------------------------- | :----------------------------------------------------------- |
| 关键字     | Abstract  class                                      | Interface                                                    |
| 组成       | 构造方法、普通方法、抽象方法、static方法、常量、变量 | 抽象方法、static、final变量 ，Java 8中可定义静态方法，用接口名调用，Java 9 中私有方法和私有静态方法 |
| 子类的使用 | Extends一个类                                        | Implements多接口                                             |
| 关系       | 可以实现多个接口                                     | 不能继承抽象类，可继承多个接口                               |
| 权限       | 各种权限                                             | 只有public                                                   |
| 限制       | 单继承局限                                           | 无局限                                                       |
| 设计层面   | 模版设计  ，对类的抽象                               | 行为规范  ，对行为的抽象                                     |
| 子类       | 都必须有子类，并且覆写全部方法                       | 都必须有子类，并且覆写全部方法                               |
| 实例化对象 | 依靠子类对象的向上转型进行对象的实例化               | 依靠子类对象的向上转型进行对象的实例化                       |



### 18. 成员变量和局部变量的区别？

语法形式：成员变量属于类，局部变量是在方法中定义的变量或方法的参数，成员变量被public、private、static等修饰，局部变量不能被访问控制修饰符及static修饰，但是都能被final修饰

存储方式：如果成员变量用static修饰属于类，没有static属于实例，对象在堆内存中，局部变量在栈内存中

生存时间：成员变量是对象一部分，随着对象生存，局部变量随着方法的调用自动消失

成员变量如果没有初值会被自动以类型默认值赋值（final修饰的成员变量 必须赋值），局部变量不会自动赋值



### 19. 创建一个对象用什么运算符？对象实体和对象引用有何不同？

new 运算符创建对象实例，在堆内存中，对象引用指向对象实例，引用在栈内存中。一个引用可以指向0或1个对象，对象可以有n个引用。



### 20. 什么是方法的返回值？作用是什么？

获取某个方法代码执行的结果



### 21. 类的构造方法作用？ 如果没有构造方法，能正确执行吗？

完成对象初始化的工作，没有构造方法也可以执行，会有默认的不带参数的构造方法。



### 22. 构造方法有哪些特性？

1. 名字和类名相同
2. 没有返回值，但不能用void声明构造函数
3. 生成类的对象的时候自动执行，无需调用



### 23. 静态方法和实例方法有何不同

1. 在外部调用静态方法时，可以用“类名.方法名”的方式，也可以“对象名.方法名”的方式。实例方法只有后面的方式，即静态方法无需创建对象调用。
2. 静态方法访问本类的成员时，只允许访问静态成员，不允许访问实例成员变量和实例方法，实例方法没有限制。



### 24. 对象的相等与指向它们的引用相等有什么不同？

对象相等比较的是内存中的内容是否相等，引用相等比较的是指向的内存地址是否相等



### 25. 在调用子类构造方法之前会先调用父类的无参构造，目的？

帮助子类做初始化工作



### 26. ==与equals（重要！！！）

== ：判断两个对象的地址是不是相等，即判断两个对象是不是同一个对象，**基本数据类型==是比较值**，**引用数据类型==比较的是内存地址**

equal：也是判断两个对象是否相等

1. 类没有覆盖equals（）方法，等价于==比较

2. 类覆盖了equals（）方法，**一般情况都覆盖来比较内容、值是否相等**，如果内容相等，返回true

   **String中的equals方法被重写过，是比较对象的值**，**object没有重写，比较的是地址**



### 27. hashCode 与 equals（重要！！！）

面试官可能的问题：你重写过hashcode和equals吗？ 为什么重写equals时必须重写hashcode方法？

hashcode: 获取哈希码，确定对象在哈希表中的索引位置，只在散列表中有用。hashcode定义在object. java中，所以任何类都包含hashcode（）函数， **所有的类都可以通过equals()去比较两个对象是否相等**。 。

​    例如：将对象放入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，会调用equals方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其它位置。

1. 对象相等，hashcode相等；
2. hashcode相等，对象不一定相等。
3. 因此，equals方法被覆盖过，hashcode方法也必须要被覆盖。

[hashcode和equals的详细说明]( https://www.cnblogs.com/skywang12345/p/3324958.html )



### 28. Java中为什么只有值传递？

- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。
- 一个方法可以改变一个对象参数的状态。
- 一个方法不能让对象参数引用一个新的对象。

[详细解释]( https://juejin.im/post/5e18879e6fb9a02fc63602e2 )