### 8. 什么是线程死锁？如何避免？

多个线程被同时阻塞，它们中一个或全部都在等待某个资源被释放，线程无限期阻塞，因此程序不可能正常终止。

四个必要条件：

1. 互斥条件：
   进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

2. 不可剥夺条件:
   进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。

3. 请求与保持条件：
   进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

4. 循环等待条件:
   存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示。

   直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义构成等待环所 要求的条件更严，它要求Pi等待的资源必须由P(i+1)来满足，而循环等待条件则无此限制。 例如，系统中有两台输出设备，P0占有一台，PK占有另一台，且K不属于集合{0, 1, …, n}。

   Pn等待一台输出设备，它可以从P0获得，也可能从PK获得。因此，虽然Pn、P0和其他 一些进程形成了循环等待圈，但PK不在圈内，若PK释放了输出设备，则可打破循环等待, 如图所示。因此循环等待只是死锁的必要条件。
   ![1593438147405](D:\mygit\Study-for-Offer\CS\images\1593438147405.png)

避免死锁：破坏其中一个条件

1. 破坏互斥条件：无法破坏，因为锁本来就是想让他们互斥的，临界资源需要互斥访问。

1. 破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用
2. 破坏”请求与保持条件“：第一种方法静态分配即每个进程在**开始执行时就申请他所需要的全部资源**。第二种是动态分配即每个进程**在申请所需要的资源时他本身不占用系统资源**。
3. 破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。

### 9. sleep（）方法和wait（）方法的区别和共同点？

主要区别：sleep方法没有释放锁，wait方法释放锁

都可以暂停线程执行

wait用于线程间通信交互，sleep通常用于暂停执行

wait调用后，线程不会自动苏醒，需要别的线程调用同一对象的notify（）或notifyAll（）方法。sleep方法会自动苏醒。



### 10. 为什么用start（）方法时会执行run（）方法，为什么不直接用run（）？

**经典的Java多线程问题！**

new一个Thread，线程进入了新建状态，调用start（）方法，会启动一个线程并使线程进入**就绪**状态，分配到时间片之后就可以运行了。start（）会执行线程的准备工作，然后自动执行run（）方法，这是真正的多线程工作，直接执行run方法，会把run（）当一个main线程下普通方法执行，并不会在某个线程中执行，所以不是多线程工作。

**总结：**调用start（）可以启动线程并使线程进入就绪状态，run方法是thread普通方法调用，还是在主线程执行。